# Twilight Compiler Middle End Passes Specification v1.0

## 1. Introduction

### 1.1 Purpose

This document specifies the core analysis and optimization passes that operate within the Twilight compiler (`twilightc`) middle end. These passes transform the initial canonical Twilight Intermediate Representation (TIR-SSA) received from the frontend into an optimized and validated TIR-SSA representation suitable for backend code generation. They are responsible for enforcing Twilight's core safety guarantees, performing NOVA-specific analyses, and improving code efficiency.

### 1.2 Scope

This specification details the purpose, inputs, outputs, and core algorithmic responsibilities of each major pass within the middle end pipeline. It covers core semantic analyses (type checking, borrow checking, domain analysis, gas estimation, pipeline analysis, VCGen) and standard/NOVA-specific optimization passes. It does not provide exhaustive implementation details for each algorithm but defines their role within the compiler architecture.

### 1.3 Input/Output

* **Input:** Canonical TIR-SSA representation of a crate, as generated by the frontend (`specs/compiler/06-frontend.md`). This includes function definitions, basic blocks, instructions in SSA form, and initial metadata (like source locations).
* **Output:** Optimized, validated TIR-SSA representation, with instructions and functions further annotated with metadata derived from analysis passes (e.g., aggregated domains, gas costs, verification info).

## 2. Pass Management & Ordering

* **Pass Manager:** A central component within `twilightc` orchestrates the execution of middle-end passes in a defined sequence. It manages the TIR representation and the flow of analysis results between passes.
* **Pass Order (Illustrative):** The precise order may be refined based on dependencies, but a logical sequence is:
    1.  Final Type Checking (TIR-SSA)
    2.  Implicit Borrow Check & Lifetime Analysis
    3.  Conflict Domain Analysis
    4.  Gas Estimation & Annotation
    5.  Pipeline Analysis
    6.  Verification Condition Generation (VCGen)
    7.  Optimization Pass Sequence (potentially iterative)
    8.  Final Validation/Cleanup
* **Analysis Results:** Passes may compute analysis results (e.g., type maps, borrow checking state, domain sets) that are consumed by subsequent passes. The Pass Manager facilitates access to these results.

## 3. Core Analysis Passes

These passes perform essential semantic validation and gather information required for safety, optimization, and NOVA integration. They operate on the TIR-SSA form.

### 3.1 Final Type Checking (TIR-SSA)

* **Goal:** Rigorously verify that all instructions, operands, SSA registers, phi nodes, function calls, and aggregate operations within the canonical TIR-SSA representation adhere to the TIR type system (`specs/compiler/07-tir.md`, Section 4).
* **Input:** Canonical TIR-SSA.
* **Output:** Validated TIR-SSA or type error diagnostics.
* **Process:** Traverses the TIR, checking type consistency for every operation according to the instruction semantics defined in the TIR ISA specification (`specs/compiler/07-tir.md`, Section 6). Verifies SSA definitions/uses and phi node consistency. Confirms function call arguments/return types match callee signatures.

### 3.2 Implicit Borrow Check & Lifetime Analysis

* **Goal:** Statically enforce Twilight's implicit memory safety rules (one mutable XOR multiple shared borrows; borrows cannot outlive owners) on the TIR-SSA representation, as defined conceptually in the language specification (`specs/language/01-core-language.md`, Section 5). This is a critical safety pass.
* **Input:** Type-checked TIR-SSA, CFG information.
* **Output:** Validated TIR-SSA or memory safety violation diagnostics.
* **Process:** Employs dataflow analysis over the CFG, likely modeling abstract memory locations (Places), active borrows (Loans) with types (Shared/Mutable) and inferred lifetimes (Regions). Checks for borrow conflicts (aliasing rules) and lifetime violations (dangling references) at relevant points (assignments, function calls, potentially aggregate access). Errors must clearly explain the violation in terms of source code constructs, using `srcloc` and `debug_name` metadata.

### 3.3 Conflict Domain Analysis

* **Goal:** Statically compute the aggregated sets of Conflict Domains potentially read (`aggregate_read_domains`) and written (`aggregate_write_domains`) by each function, including analyzing the effects of callees (inter-procedural analysis). This metadata is crucial for the NOVA runtime scheduler and consensus.
* **Input:** Type-checked, borrow-checked TIR-SSA, call graph information, potentially `.meta` files from dependencies.
* **Output:** TIR-SSA functions annotated with `aggregate_read_domains` and `aggregate_write_domains` metadata (sets of domain hashes). Functions involved in recursion are marked.
* **Process:** Performs an inter-procedural fixed-point analysis over the call graph. Computes local domains based on `state_read`/`state_write` instructions within each function. Propagates domain sets from callees to callers, handling recursion and respecting explicit annotations (`#[reads]`, `#[writes]`, `#[conflict_free]`). Uses dependency metadata or requires explicit annotations for external calls. Falls back to coarse-grained domains (e.g., `namespace:*`) for unresolved dynamic accesses, issuing warnings.

### 3.4 Gas Estimation & Annotation

* **Goal:** Annotate TIR instructions with estimated gas costs based on a canonical protocol-defined Gas Cost Table. Computes a basic static aggregate gas estimate per function.
* **Input:** TIR-SSA, canonical Gas Cost Table (protocol parameter).
* **Output:** TIR-SSA with instructions annotated with `gas` (static cost) and potentially `gas_dynamic` (identifier for runtime calculation) metadata. Functions annotated with `gas_estimate_static`.
* **Process:** Traverses TIR instructions. For each instruction or HFI call equivalent, looks up its cost in the Gas Cost Table. Annotates the instruction with the static cost (`gas`) and a dynamic cost identifier (`gas_dynamic`) if applicable. Sums static costs per function for the basic `gas_estimate_static` metadata (note: this sum ignores control flow).

### 3.5 Pipeline Analysis

* **Goal:** Analyze function-level Conflict Domain metadata against developer-provided `#[pipeline(...)]` annotations to check for consistency and potentially infer pipeline affinity heuristically.
* **Input:** TIR-SSA with aggregated domain metadata, pipeline annotation information, and a pipeline configuration mapping hints to expected domains.
* **Output:** TIR-SSA functions annotated with validated `pipeline_hint` metadata or diagnostics for inconsistencies. May include informational `inferred_pipeline_hint` metadata.
* **Process:** For each function, compares its aggregated read/write domain sets against the expected domains associated with its `#[pipeline(...)]` hint (if present). Issues warnings for unexpected domain accesses or potentially missing expected accesses. If no hint exists, may optionally apply heuristics based on dominant accessed domains to infer a hint.

### 3.6 Verification Condition Generation (VCGen)

* **Goal:** Translate formal specifications embedded in the source code (e.g., `assert_pre`, `assert_post`, `assert_invariant`) into logical formulas (Verification Conditions, VCs) suitable for external verification tools (e.g., SMT solvers).
* **Input:** Annotated TIR-SSA, axiomatic semantics rules for TIR.
* **Output:** A set of VCs (typically in SMT-LIB 2 format) linked to source assertions via `verification_condition_id` metadata in TIR and summarized in the `.meta` file.
* **Process:** Employs Weakest Precondition (WP) calculus or symbolic execution, traversing the TIR backwards from assertions. Translates TIR constructs and state accesses into logical predicates based on axiomatic semantics. Generates VCs representing proof obligations (e.g., `FunctionPrecondition => wp(FunctionBody, Postcondition)`). Handles loop invariants and `old()` state references.

*(Details in `specs/verification/19-vcgen.md`)*

## 4. Optimization Passes

These passes transform the TIR-SSA to improve performance, reduce gas costs, or minimize code size, while strictly preserving program semantics.

### 4.1 Optimization Levels

* The compiler supports different optimization levels (e.g., `-O0`, `-O1`, `-O2`, `-O3`, `-Oz`) controlled via CLI flags.
* The Pass Manager enables different sets and sequences of optimization passes based on the selected level. `-O0` performs minimal/no optimizations for debugging, while higher levels (`-O2`, `-Oz` typical for release) enable more aggressive optimizations.

### 4.2 Standard Optimizations

A suite of standard compiler optimizations adapted for TIR-SSA, including potentially:

* **Dead Code Elimination (DCE):** Removes unused instructions and unreachable code.
* **Constant Propagation / Folding (SCCP):** Replaces variables with constants and evaluates constant expressions at compile time.
* **Function Inlining:** Replaces function calls with the callee's body based on heuristics (size, call frequency, gas savings).
* **Loop Optimizations (LICM, Strength Reduction):** Moves loop-invariant code out of loops; replaces expensive induction variable operations with cheaper ones. Requires loop analysis.
* **Common Subexpression Elimination (CSE) / Global Value Numbering (GVN):** Eliminates redundant computations.
* **Instruction Combination / Peephole Optimization:** Replaces instruction patterns with simpler equivalents.
* **Memory-to-Register Promotion / SROA:** Promotes temporary stack allocations (if used internally) to SSA registers.

### 4.3 NOVA-Specific Optimizations

Optimizations leveraging knowledge of the NOVA environment:

* **Gas-Aware Optimizations:** Uses `gas` metadata to guide decisions, e.g., choosing lower-gas instruction sequences, factoring gas savings into inlining heuristics.
* **State Access Optimizations (Cautious):** Potentially reorder non-conflicting `state_read` operations or eliminate redundant reads based on domain information and alias analysis, ensuring semantics are preserved. Write combining/elimination is generally unsafe due to observability.

## 5. Semantic Preservation Requirement

* **CRITICAL:** All optimization passes MUST rigorously preserve the observable semantics of the program as defined by the Twilight language specification. This includes computational results, the order of state modifications and event emissions, and conditions causing reverts or panics. Gas consumption behavior should decrease or stay equivalent for the same logical work.
* **Verification:** Achieved through careful implementation, extensive testing (differential testing, fuzzing), semantic equivalence checking where possible, and code audits.