# Twilight Intermediate Representation (TIR) Specification v1.0

## 1. Introduction

### 1.1 Purpose

This document defines the structure, format, instruction set, and core principles of the Twilight Intermediate Representation (TIR). TIR serves as the central, unified representation of Twilight code after parsing and initial semantic analysis by the frontend. It acts as the substrate upon which compiler optimizations, NOVA-specific analyses (conflict domains, gas), verification steps, and backend code generation (WASM, potentially NOVA-BC) operate.

### 1.2 Design Goals & Philosophy

* **Syntax Agnostic:** TIR losslessly represents the semantics of code written in any supported Twilight Syntax Mode (TSM), providing a common representation after the frontend stage.
* **Analysis & Optimization Friendly:** Designed to facilitate standard compiler analyses (data flow, control flow) and optimizations through the use of Static Single Assignment (SSA) form and explicit control flow.
* **NOVA-Aware:** Explicitly represents blockchain and NOVA-specific concepts (state access with domains, events, context access, gas information) as first-class IR constructs or metadata.
* **Metadata Rich:** Allows association of detailed metadata (source locations, gas costs, domain hashes, verification conditions, debug info) with IR elements.
* **Target Agnostic (Primarily):** While containing NOVA-specific information via intrinsics and metadata, the core IR structure is designed to be suitable for targeting multiple backends (WASM initially).
* **Verifiable & Auditable:** Possesses a well-defined structure and a canonical textual format (`.tir`) suitable for compiler debugging, auditing, and consumption by verification tools.

### 1.3 Scope

This specification covers the structural model of TIR, the use of SSA, the general instruction format, type representation, metadata system, the canonical TIR-SSA instruction set, function representation, and memory model concepts within TIR. It does not detail the specific algorithms for lowering source code to TIR or the algorithms for optimization passes operating on TIR.

## 2. Core Concepts

### 2.1 Structural Model

TIR follows a hierarchical structure:

* **Module/Crate:** Represents a single compilation unit. Contains global constants, type definitions, function definitions, and module-level metadata.
* **Function Definition:** Represents a single Twilight function or method. Contains its signature, aggregated metadata, and a Control Flow Graph (CFG).
* **Basic Block:** A sequence of non-terminating instructions followed by exactly one terminator instruction. Represents a straight-line execution path identified by a label (e.g., `%entry`).
* **Instruction:** An atomic operation, typically assigning a result to an SSA virtual register.

### 2.2 Static Single Assignment (SSA) Form

Canonical TIR is represented in SSA form to facilitate analysis and optimization.

* **Principle:** Every variable (represented as a virtual register, e.g., `%reg1`, `%tmp5`) is assigned a value exactly once in the program text.
* **Virtual Registers:** Temporary values and local variable states are represented by virtual registers (e.g., `%result`, `%counter`, `%addr_ptr`).
* **`phi` Instructions:** To merge values for a variable coming from different control flow paths, a `phi` instruction is placed at the beginning of the merge block. It selects the correct value based on the predecessor block from which control arrived.
    ```tir
    %merged_val: i64 = phi i64 [ %val_from_blockA, %label_blockA ], [ %val_from_blockB, %label_blockB ]
    ```

### 2.3 TIR Levels (Conceptual)

While the canonical form is TIR-SSA, the compiler process involves conceptual levels:

* **TIR-HL (High-Level):** The initial IR generated by the frontend. May retain some higher-level constructs (e.g., structured control flow, named field access) closer to the source.
* **TIR-SSA (Canonical Low-Level):** The primary representation for analysis and optimization. Fully lowered to SSA form with explicit basic blocks, terminators, phi nodes, and potentially more explicit memory operations for aggregates. This is the form targeted by this ISA specification and the textual `.tir` format.

## 3. General Format & Conventions

### 3.1 Textual Format (`.tir`)

A human-readable textual format, typically with a `.tir` extension, is defined for debugging, auditing, and tooling. Its general instruction format is:

`[%result: ResultType =] opcode <OperandType?> Operand1, <OperandType?> Operand2, ... [!Metadata{...}]`

* `%result`: (Optional) The SSA virtual register assigned the result value.
* `ResultType`: The TIR type of the result register.
* `opcode`: Mnemonic identifying the operation (e.g., `add`, `state_read`, `call`, `br_if`).
* `<OperandType?>`: Optional explicit type for operands, particularly constants.
* `OperandN`: Operands (see below).
* `[!Metadata{...}]`: Attached metadata map (see Section 5).

*(A separate specification may detail the full `.tir` file format including module structure, type definitions, etc.)*

### 3.2 Operands

Operands within TIR instructions can be:

* **Virtual Register (`%reg`):** An SSA virtual register identifier (e.g., `%counter`, `%balance`). Must be defined before use within its scope.
* **Constant (`Const`):** A literal value (e.g., `10u64`, `true`, `"Error Message"`, `0xabc...def` (address/hash)). Type may be specified explicitly (`<Type> Const`) or inferred.
* **Global Identifier (`@Global`):** A named reference to a function (`@MangledFunctionName`) or a global constant (`@MY_CONST`).
* **Basic Block Label (`%Label`):** An identifier referencing a specific basic block within the current function (e.g., `%entry`, `%loop.body`).
* **Type (`<Type>`):** A TIR type name used in type annotations or certain instructions (e.g., `u64`, `%MyStruct`, `ptr<u8>`).

## 4. Type Representation in TIR

TIR maintains strong typing. Types from Twilight source are mapped as follows:

* **Primitives:** Mapped directly.
    * `bool` -> `bool`
    * `u8`..`u256` -> `u8`..`u256`
    * `i8`..`i256` -> `i8`..`i256`
    * `string` -> `string` (Opaque immutable byte sequence type; implementation details handled by stdlib/backend)
    * `address` -> `address` (Opaque address type; size defined by protocol)
    * `hash256` -> `hash256` (Opaque 32-byte hash type)
    * `timestamp` -> `u64`
    * `blocknumber` -> `u64`
    * `void` -> `void` (For functions returning no value)
* **Compound Types:**
    * **Structs:** Represented by named aggregate types defined at the module level (e.g., `%Point = type { i64, i64 }`). Fields accessed by constant index (0, 1, ...).
    * **Enums (Tagged Unions):** Lowered into a structural representation, commonly a struct containing a discriminant (tag) and storage space for the largest variant (e.g., `%Option_u64 = type { tag: u8, value: u64 }`). Requires intrinsics or specific instruction patterns for safe construction and matching (e.g., `get_enum_tag`, `extract_enum_value`).
    * **Tuples:** Represented as anonymous aggregate types (e.g., `{ i64, bool, %MyType }`). Accessed by constant index.
    * **Arrays (`array<T, N>`):** Represented as fixed-size array types `[N x T]` (e.g., `[32 x u8]`). Accessed by index.
* **Opaque Types (Collections):**
    * `vector<T>`, `map<K, V>`: Represented as opaque named types in TIR (e.g., `@vector_u64`, `@map_address_string`). Operations (`push`, `get`, `insert`, etc.) are performed via `call` instructions to standard library functions which manage the underlying memory and implementation details.
* **Generics:** Generic source types are typically monomorphized before or during lowering to TIR-SSA. TIR operates on concrete instantiations (e.g., `%Option_u64`, `@vector_address`).
* **Pointers (`ptr<T>`):** Generally avoided in canonical TIR for safe contract code. May appear internally for backend lowering or specific low-level HFI/intrinsic definitions (e.g., `ptr<u8>` for byte buffers).

## 5. Metadata Specification

Metadata provides essential context attached to TIR elements.

### 5.1 Mechanism (`!Metadata{...}`)

* A flexible key-value map associated with Modules, Functions, Basic Blocks, or Instructions.
* Textual representation uses `!{ key1: value1, key2: value2, ... }`.

### 5.2 Standard Keys & Definitions

Key metadata includes (but is not limited to):

* **`srcloc`** (string): Source location mapping (`"file:line:col"`). Essential for diagnostics and debugging. Attaches primarily to instructions.
* **`gas`** (u64): Estimated base static gas cost for an instruction. Attaches to instructions.
* **`gas_dynamic`** (string): Identifier for a runtime function to calculate dynamic gas costs (e.g., based on operand size). Attaches to instructions with variable costs.
* **`domain_hash`** (hash32b): The Conflict Domain hash for state accesses. Mandatory for `state_read`/`state_write`.
* **`domain_access_type`** (enum {READ, WRITE}): Explicitly marks state access type. Often implicit in opcode.
* **`pipeline_hint`** (string): Developer hint for scheduling. Attaches to Functions.
* **`verification_condition_id`** (string|u64): Links IR assertion points to formal VCs. Attaches to assertion intrinsics.
* **`is_recursive`** (bool): Marks functions involved in recursion. Attaches to Functions.
* **`aggregate_read_domains`** (Set<hash32b>): Aggregated read domains for a function. Attaches to Functions.
* **`aggregate_write_domains`** (Set<hash32b>): Aggregated write domains for a function. Attaches to Functions.
* **`debug_name`** (string): Original source variable name associated with an SSA register. Attaches to assignment instructions (for debug builds).
* **`debug_type`** (string): Original source type associated with an SSA register. Attaches to assignment instructions (for debug builds).

*(Detailed format and usage defined further in Metadata Emission and `.meta` File specifications).*

## 6. Instruction Set Architecture (ISA) - Canonical TIR-SSA

This section outlines the core instructions. All instructions operate on SSA virtual registers or constants and produce results in SSA virtual registers (where applicable).

### 6.1 Terminator Instructions

These instructions must end every basic block and define control flow transfer.

* `ret void`
* `ret <Type> %value`
* `br %DestLabel`
* `br_if %condition, %TrueLabel, %FalseLabel` (`%condition` must be `bool`)
* `revert <Type> %message_value` (Halts tx, reverts state, consumes gas used)
* `panic <Type> %message_value` (Halts tx, reverts state, consumes *all* gas)
* `unreachable` (Indicates logically unreachable code; runtime execution causes panic)

### 6.2 Standard Binary Arithmetic Operations

Operate on integer types (`uN`/`iN`). Default behavior reverts on overflow/underflow.

* `%result: Type = add <Type> %lhs, %rhs`
* `%result: Type = sub <Type> %lhs, %rhs`
* `%result: Type = mul <Type> %lhs, %rhs`
* `%result: Type = div_u <Type> %lhs, %rhs` (Unsigned division; panics if `%rhs` is zero)
* `%result: Type = div_s <Type> %lhs, %rhs` (Signed division; panics if `%rhs` is zero or on `MIN / -1` overflow)
* `%result: Type = rem_u <Type> %lhs, %rhs` (Unsigned remainder; panics if `%rhs` is zero)
* `%result: Type = rem_s <Type> %lhs, %rhs` (Signed remainder; panics if `%rhs` is zero or on overflow)

### 6.3 Explicit Arithmetic Operations

Provide defined overflow behavior without reverting.

* `%result: Option<Type> = checked_add <Type> %lhs, %rhs` (Returns `None` on overflow)
* `%result: Option<Type> = checked_sub <Type> %lhs, %rhs`
* `%result: Option<Type> = checked_mul <Type> %lhs, %rhs`
* `%result: Option<Type> = checked_div_[u|s] <Type> %lhs, %rhs` (Returns `None` on div by zero/overflow)
* `%result: Type = wrapping_add <Type> %lhs, %rhs` (Two's complement wrap)
* `%result: Type = wrapping_sub <Type> %lhs, %rhs`
* `%result: Type = wrapping_mul <Type> %lhs, %rhs`
* `%result: Type = saturating_add <Type> %lhs, %rhs` (Clamps to min/max)
* `%result: Type = saturating_sub <Type> %lhs, %rhs`

### 6.4 Bitwise Binary Operations

Operate on integer types (`uN`/`iN`).

* `%result: Type = and <Type> %lhs, %rhs`
* `%result: Type = or <Type> %lhs, %rhs`
* `%result: Type = xor <Type> %lhs, %rhs`
* `%result: Type = shl <Type> %value, %amount` (Shift Left)
* `%result: Type = shr_l <Type> %value, %amount` (Logical Shift Right)
* `%result: Type = shr_a <Type> %value, %amount` (Arithmetic Shift Right)

### 6.5 Unary Operations

* `%result: Type = neg <Type> %operand` (Arithmetic Negation for `iN`; reverts on `neg(MIN)`)
* `%result: Type = not <Type> %operand` (Bitwise NOT for `uN`/`iN`)

### 6.6 Comparison Operations

* `%result: bool = icmp <Cond> <Type> %lhs, %rhs`
    * `<Cond>`: `eq`, `ne` (equal, not equal), `ugt`, `uge`, `ult`, `ule` (unsigned >, >=, <, <=), `sgt`, `sge`, `slt`, `sle` (signed >, >=, <, <=).
    * `<Type>`: Operands type (integers, `address`, `bool`).

### 6.7 Logical Operations

Logical AND (`&&`) and OR (`||`) are typically implemented using control flow (`br_if`). `select` provides conditional value selection without branching.

* `%result: Type = select bool %condition, <Type> %true_value, <Type> %false_value`

### 6.8 Memory / State Access Operations

These interact with persistent contract storage. `domain_hash` metadata is mandatory.

* `%result: Type = state_read <Type> %key_reg [!Metadata{ domain_hash: Hash32b, ... }]` (`%key_reg` holds the physical storage key)
* `state_write <Type> %key_reg, %value_reg [!Metadata{ domain_hash: Hash32b, ... }]`

*(Load/store instructions for local memory are generally avoided in canonical TIR-SSA).*

### 6.9 SSA Operations

* `%result: Type = phi <Type> [ %val1, %Label1 ], [ %val2, %Label2 ], ...` (Must appear only at the start of a basic block)

### 6.10 Function Call Operations

Represents direct, static function calls. Method calls are lowered to calls targeting specific implementation functions.

* `%result: RetType = call <RetType> @MangledFunctionName(<ArgType1> %arg1, <ArgType2> %arg2, ...)`

### 6.11 Type Conversion Operations

* `%result: ToType = zext <FromType> %value to <ToType>` (Zero Extend for `uN`)
* `%result: ToType = sext <FromType> %value to <ToType>` (Sign Extend for `iN`)
* `%result: ToType = trunc <FromType> %value to <ToType>` (Truncate integers)
* `%result: ToType = bitcast <FromType> %value to <ToType>` (Reinterpret bits; use restricted/cautioned)

### 6.12 Aggregate Type Operations

For operating on immutable aggregate SSA values (structs, tuples, arrays).

* `%result: ElemType = extractvalue <AggType> %aggregate_val, <index>` (Extract element at constant index)
* `%result: AggType = insertvalue <AggType> %aggregate_val, <ElemType> %element_val, <index>` (Create new aggregate with element at constant index replaced)

*(Pointer-based `get_element_ptr`, `load`, `store` may be used in later, non-canonical stages or backends).*

### 6.13 NOVA/Blockchain Intrinsic Operations

Represent interactions with the host environment, mapping closely to HFI calls.

* `emit_event %topics_vec, %data_vec [!Metadata{...}]` (Triggers HFI `contract_emit_event`)
* `%result: Type = get_ctx <ContextVar> [!Metadata{...}]` (Gets context via HFI, e.g., `get_ctx Sender -> address`)
* `%result: hash256 = crypto_hash <HashType> %input_data [!Metadata{...}]` (Performs hashing via HFI, e.g., `crypto_hash Keccak256 %data -> hash256`)
* *(Assertion intrinsics for verification, e.g., `assert_intrinsic <Kind> %condition, %message_id`)*

## 7. Function Representation & Calling Convention

* **Definition:** Functions are defined using the `define` keyword:
    ```tir
    define <Visibility?> <Linkage?> <ReturnType> @MangledFunctionName(<ArgType1> %arg1, ...) [!Metadata {...}] {
        %entry:
            ... basic blocks ...
        ret <ReturnType> %value
    }
    ```
* **Arguments:** Passed conceptually as SSA virtual registers (`%arg1`, `%arg2`, ...).
* **Return Value:** Returned via the `ret` instruction, placed into the result register of the `call` instruction by the caller.
* **Convention:** TIR uses a logical calling convention. Argument passing (copy vs. move vs. implicit borrow) is determined by the type and compiler analysis based on language rules. The backend translates this into the physical ABI (register/stack usage) for the target platform (WASM).

## 8. Memory Model Representation

TIR's memory model for non-persistent data focuses on SSA values and abstracts low-level details.

* **Local Variables/Temporaries:** Represented as SSA virtual registers (`%reg`). Backend handles mapping to physical registers/stack slots.
* **Aggregates (Structs, Tuples, Arrays):** Primarily treated as immutable SSA values where possible, operated on via `extractvalue`/`insertvalue`. Larger aggregates may be handled implicitly by reference or lowered to pointer-based access later.
* **Dynamic Collections (`vector`, `map`) & `string`:** Represented as opaque types (e.g., `@vector_u64`). Operations are via `call` to standard library functions which interact with the runtime allocator HFI.
* **Stack/Heap Allocation:** No explicit `alloca`, `malloc`, or `free` instructions in canonical TIR for contract code. Memory managed via SSA values or runtime-managed collections.
* **Pointers (`ptr<T>`):** Avoided for general use. Appear primarily in HFI signatures or potentially internal lowering stages.
* **Load/Store:** Primarily used for persistent state (`state_read`/`state_write`). Avoided for local SSA variable access.